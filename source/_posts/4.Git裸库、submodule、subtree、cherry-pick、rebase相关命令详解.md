---
title: Git.4.裸库、submodule、subtree、cherry-pick、rebase相关命令详解
date: 2019-02-17 15:04:32
tags: 
  - Git
categories: 
	- 版本控制工具
---

## git 裸库与submodule
### git裸库 
git裸库是没有工作区的Git仓库 一般用于服务器端
>gut init --bare


### submodule
进行多模块开发时候使用，解决了每次依赖的模块更新都要配置一次重复操作的问题  
将一个仓库引用到另外一个仓库中的操作
``` shell.sh
#引入Git工程 放入到mymodule 文件夹中，该文件夹之前不能存在
git submodule add git@github.com:dgqg1223/dgqg1223.git mymodule
git add .
git commit -m 'add submodule'
# 获取远程变化的第一种方式
cd mymodule
git pull
# 获取远程变化的常用方式 一个命令更新所有子模块
git submodule foreach git pull
git add .
git commit -m 'update submodule'
```
submodule 的克隆
在我们克隆主项目时候不会克隆子库中的数据，需要我们手动克隆
```
# 先初始化 让git 识别出模块
git submodule init 
git submodule update --recursive

# 第二种方法 使用clone参数直接
git clone git@github.com:dgqg1223/dgqg1223.git myclone --recursive
```
submodule 的删除
```
git -rm --cached mymodule
git status
rm -rf mymodule
git add .
git status
git commit -m 'remove submodule'
git push
rm .gitmodules
git add .
git commit -m 'remove .submodules'
git push
```
submodule的缺点
主工程和子工程都可以对子工程代码进行修改，会造成一些问题，官方推荐使用Git subtree


## Git subtree
与submodule区别 submodule 是引用子对象，而subtree是将子对象文件都拷贝到主工程中

```
#使用 --squash 参数
git remote add subtree-origin git@github.com:dgqg1223/dgqg1223.git myclone 
git remote show
#--squash 是可选参数该参数也可以使用在morege 压缩合并远程提交记录 使用这个参数 则看不到之前的提交的记录 
#使用--squash 会出现问题，我们如果使用--squash 那么我们进行pull等操作时候也要加上--squash
#三种方式等同
git subtree add --prefix=subtree subress-origin master --squash
git subtree add -P subtree subress-origin master --squash
git subtree add --prefix subtree subress-origin master --squash

# 获取更新
git subtree pull -P subtree subress-origin master --squash
#上传主工程
git push
#上传子工程
git subtree push -P subtree subress-origin master 
#这里我们修改子工程文件后 重新执行 git subtree pull 会出现错误
git subtree pull -P subtree subress-origin master --squash
#修改生成的重复代码后再提交就不会报错



#不使用 --squash 参数
git remote add subtree-origin git@github.com:dgqg1223/dgqg1223.git 
git sub add -P subtree-origin master
# 修改子工程
··· ···
git push
# 主工程获取更新
git subtree pull --prefix=subtree subtree-origin master
# 主工程下修改子工程文件
··· ···
#主工程提交修改子工程文件
git subtree push --prefix=subtree subtree-origin master
#修改生成的重复代码后再提交就不会报错
```

解释为什么都使用或都没使用--squash参数还会出现冲突
三方合并时候主工程提交点 和子工程提交点都有之前提交的信息，产生了2个合并提交点合并信息，主提交点寻找之前提交点，子工程点也找之前提交点，发现没有共同提交点。（subtree融入子工程并不是分支本质是两个仓库）

## subtree split 分割工程
我们可以使用split参数分割工程 使工其中的模块建立独立的工程  
优点：和我们直接手动拷出文件，建立Git工程相比，split可以保留要分割这部分代码的相关日志操作。  
缺点：在我们对多个文件进行修改提交操作后，其中有我们需要分割出去的代码，那么这段提交日志也会被分割出去。


## git cherry-pick
对本地分支的提交信息进行分支应用
应用场景：本来应该再master分支上修改文件，误操作再develop上修改
```
#环境搭建 主分支master 子分支 develop ，develop 修改文件提交
#切换到master分支
··· ···
#使用cherry-pick将develop分支的commit应用到master分支
git cherry-pick 5a0dd2f
git log
```
注意事项：当我们使用cherry-pick时候 不能跳分支操作否则会报冲突错误，这时候我们需要手动解决冲突 


## git rebase
rebase 翻译：变基、衍合  
rebase 的功能类似于merge ，不过工作方式有显著的差异  
rebase 会修改提交历史。会将之前的提交指向要被合并的分支的最后一次提交，分支记录变为一条直线  
rebase最佳实践： 不要对master分支使用rebase，否则会引起很多问题，一般来说执行rebase的分支都是自己的本地分支，没有推送到远程版本库,不要再与其他人共享的分支上进行操作

```
#环境搭建 master分支 develop分支 text分支 在develop和text分支进行若干提交
··· ···
#develop rebase 到test分支
git rebase develop
#执行后可能会报错冲突  
#根据提示信息我们可以使用 git reagse --abort 返回到合并之前的状态
#也可以使用 git rebase --skip 舍弃test分支中冲突操作的提交进行合并
#也可以手动解决冲突下面修改冲突并提交
vi test.txt
git rebase --continue
#测试 再将develop merge text 这时候会直接进行 Fast-forward
```